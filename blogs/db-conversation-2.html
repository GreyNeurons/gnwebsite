<!doctype html>
<html class="no-js" lang="en">
    <head>
    
        <link rel="stylesheet" href="/css/normalize.css">
        <link rel="stylesheet" href="/css/bulma.css">
        <link rel="stylesheet" href="/css/main.css">
    
        <script>
          // Set page-specific meta description
          window.pageMetaDescription = "Designing PostgreSQL Database Using AI: Why You Should Avoid ENUMs & How MySQL Offers More Storage Options";
        </script>
    
        <script defer src="/js/head-component.js"></script>  
    </head>
    <body>
        
        <blog-header>
            <span slot="bread-crumb-current-page">Designing DB with AI</span>
        </blog-header>

 
        <section>
            <div class = "blog-container">
                    <!-- INSERT CONTENT HERE -->
                <div class ="title is-1">
                    Designing PostgreSQL Database Using AI: Why You Should Avoid ENUMs & How MySQL Offers More Storage Options
                </div>
                <div class = "content">
                AI-powered tools like ChatGPT, Gemini, and DeepSeek have changed how developers approach database design. Today, teams routinely use AI to <b>generate schemas, validate ideas, and build quick prototypes</b>. But how good are these AI-generated schemas in <b>real-world applications</b>?
                </div>

                <div class = "content">
                    As we experimented with AI for designing our PostgreSQL database, we noticed that AI <b>often missed crucial best practices</b>. In this post, we will share some real-world scenarios where AI could have done a better job, and we will <b>also compare PostgreSQL and MySQL in terms of storage optimization and data type flexibility.</b>
                </div>
                <div class = "content">
                    When we started using it, <b>we were expecting AI to not only generate the schema quickly but also for ensure by default</b>
                    <ul>
                    <li>Implement the best practices or thumb rules of database design.</li>
                    <li>Infer relationship & take care of suggesting appropriate constraints.</li>
                    <li>Choose the correct data types for the column.</li>
                    <li>Optimize from a storage and query performance.</li>
                    </ul>
                </div>

                <div class = "content">
                    The reality was quite different & in this post we present few scenarios where the team thought AI could have done a better job in the first go.
                </div>

                <div class ="title is-2">Reality check #1: Lack of foreign key constraints</div>
                <div class ="content">
                    <div class = "block">In the initial script generated by AI, there were no foreign key constrains defined at all. Defining foreign keys is a basic database design principle & we thought the initial prompts were explicit for AI to generate the schema with foreign constraints. We had to repeatedly tell AI few times before it started doing it.
                    </div>    
                    <div class = "subtitle">AI generated schema without foreign keys</div>
                    <pre><code>
                        CREATE TABLE foobar(
                        id SERIAL PRIMARY KEY,
                        user_id INTEGER, <mark class="has-background-warning"> -- Missing foreign key constraints</mark>
                        amount DECIMAL(10,2)
                        );
                    </code></pre>

                    <div class = "subtitle">Corrected Schema (With Foreign Key)</div>
                    <pre><code>

                        CREATE TABLE foobar (
                            id SERIAL PRIMARY KEY,
                            user_id INTEGER <mark class="has-background-success">REFERENCES users(id)</mark>,
                            amount DECIMAL(10,2)
                        );

                    </code></pre>
 
                </div>
                <div class ="title is-2">Reality check #2: Choosing sub optimal field types</div>
                    <div class ="content">
                        In the following table say where we had ‘difficulty level’ column which can potentially have values like ‘Easy’, ‘Medium’, ‘Hard’. AI proposed varchar column with the recommendation that we store actually literal strings like ‘Easy’, ‘Medium’, ‘Hard’.
                    </div>
                    <pre><code>
                        CREATE TABLE questions (
                            id SERIAL PRIMARY KEY,
                           
                            difficulty_level VARCHAR(20) 
                            CHECK (difficulty_level IN (‘Easy’, ‘Medium’, ‘Hard’)),
                            tags JSONB DEFAULT ‘{}’::JSONB
                           );

                    </code></pre>
                    <div class="content">
                        Whoever has worked in database for a while would probably suggest you would keep difficulty_level column as SMALLINT and store values like 1,2,3 etc. in it and also define a difficulty_levels lookup table. So the final table schema looks something like below
                    </div>
                    <pre><code>
                        CREATE TABLE difficulty_levels (
                            id SMALLINT PRIMARY KEY,
                            level_name TEXT UNIQUE
                        );
                        
                        INSERT INTO difficulty_levels (id, level_name) 
                        VALUES (1, 'Easy'), (2, 'Medium'), (3, 'Hard');
                        
                        CREATE TABLE questions (
                            id SERIAL PRIMARY KEY,
                            difficulty_level SMALLINT REFERENCES difficulty_levels(id)
                        );

                    </code></pre>

                    <div class = "content">
                        Initially difficulty_level was defined as INTEGER by AI.We are <strong>anticipating to have millions of rows </strong> in the  table & row storage, index storage efficiency, and query performance is a prime concern for us.INTEGER is 4 bytes is an overkill so we had an option to either use SMALLINT or ENUM.
                        SMALLINT uses 2 bytes which is also an overkill for storing 1,2,3 values. So we thought of using ENUM type which takes only 1 bytes. Although ENUM would be good from storage perspective, if the ENUM is part of an index then index ends up taking more space then an index would take if difficulty_level column was defined as SMALLINT. This is because
                        <ul>
                            <li><b>Even though ENUM is 1 byte</b>, PostgreSQL stores an internal mapping to the text value, meaning <b>indexes must store both the internal mapping and the actual text reference.</b> </li>
                            <li><b>SMALLINT is 2 bytes but fixed</b>, making <b>B-Tree indexes smaller and faster to traverse.</b></li>
                        </ul>
                        <br>
                        Also from query performance standpoint , <b>ENUMs don’t do well in comparison to SMALLINT</b> because
                        <ul>
                            <li>In PostgreSQL, ENUM is implemented as a <b>custom data type </b>stored as text internally, <b>not as an integer.</b></li>
                            <li>Even though the storage size is <b>1 byte</b>, lookups involve <b>extra overhead in mapping ENUM values</b> to their text representation.</li>
                        </ul>
                        <br>
                        So summary as following table indicates <b>it is better to stick with SMALLINT </b> then go with ENUM
                        <table>
                            <thead>
                              <tr>
                                <th>Data Type</th>
                                <th>Storage per Row</th>
                                <th>Index Efficiency</th>
                                <th>Flexibility</th>
                                <th>Lookup Performance</th>
                              </tr>
                            </thead>
                            <tbody>
                              <tr>
                                <td><strong>ENUM (1 byte)</strong></td>
                                <td>✅ Smaller (1 byte)</td>
                                <td>❌ Worse (extra lookup)</td>
                                <td>❌ Fixed set, hard to change</td>
                                <td>❌ Text lookup overhead</td>
                              </tr>
                              <tr>
                                <td><strong>SMALLINT (2 bytes)</strong></td>
                                <td>❌ Slightly larger (2 bytes)</td>
                                <td>✅ Faster (<code>B-Tree</code> optimized)</td>
                                <td>✅ Can modify values easily</td>
                                <td>✅ Direct integer comparison</td>
                              </tr>
                            </tbody>
                        </table>

                    </div>
            
                <div class ="title is-2">Reality check #3: Missing the perfect use case for JSONB column </div> 
                <div class = "content">
                    We want to tag each row in the foobar table with variable number of tags, AI in this case ended up suggesting one column for each tag which we had given as example when prompting.

                    <pre><code>
                        CREATE TABLE foobar 
                        ( id SERIAL PRIMARY KEY,
                        tag1 VARCHAR(50), 
                        tag2 VARCHAR(50), 
                        tag3 VARCHAR(50) );
                    </code></pre>
                    <br>
                    This will not work for us because number of tags are not fixed and defining a jsonb column called as tags is perfect in this case.
                    <pre>
                        <code>
                            CREATE TABLE questions (
                                id SERIAL PRIMARY KEY,
                                tags JSONB DEFAULT '{}'::JSONB
                            );
                        </code>
                    </pre>
                </div>

                <div class="title is-2">Conclusion: AI is a Tool, Not a Replacement for Thoughtful Database Design</div>
                <div class="content">
                    <p>AI has undoubtedly made database schema generation more accessible, but it’s crucial to approach it with realistic expectations. While AI can assist in structuring schemas, human expertise remains irreplaceable in optimizing for space efficiency, indexing strategies, and query performance.</p>

                    <p>When designing a PostgreSQL database, avoiding ENUMs can prevent long-term migration and maintenance challenges, even though they might seem efficient in the short term.</p>

                    <p>On the other hand, MySQL provides more flexibility in storage choices, offering a wider range of options ( TinyINT, MediumINT ) to fine-tune performance based on specific needs.</p>

                    <table>
                    <thead>
                        <tr>
                        <th><strong>Data Type</strong></th>
                        <th><strong>PostgreSQL Equivalent</strong></th>
                        <th><strong>Storage (Bytes)</strong></th>
                        <th><strong>Best Use Case</strong></th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <td>TINYINT</td>
                        <td>❌ Not Available</td>
                        <td><strong>1 byte</strong></td>
                        <td>Flags, small counters</td>
                        </tr>
                        <tr>
                        <td>SMALLINT</td>
                        <td>SMALLINT</td>
                        <td><strong>2 bytes</strong></td>
                        <td>Small numeric values</td>
                        </tr>
                        <tr>
                        <td>MEDIUMINT</td>
                        <td>❌ Not Available</td>
                        <td><strong>3 bytes</strong></td>
                        <td>Compact storage for moderate ranges</td>
                        </tr>
                        <tr>
                        <td>INT</td>
                        <td>INTEGER</td>
                        <td><strong>4 bytes</strong></td>
                        <td>Default choice for numeric IDs</td>
                        </tr>
                        <tr>
                        <td>BIGINT</td>
                        <td>BIGINT</td>
                        <td><strong>8 bytes</strong></td>
                        <td>Large numeric values (e.g., timestamps)</td>
                        </tr>
                    </tbody>
                    </table>

                    <p>
                        Ultimately, <strong>good database design is about trade-offs</strong> — balancing readability, scalability, and storage efficiency. AI can be a helpful assistant in this process, but the final decisions should <strong>always be informed by a deep understanding of how databases actually work.</strong>
                    </p>

                </div>
               
            </div>
        </section>

        <!-- Custom Footer Component -->
        <blog-footer></blog-footer>

        <!-- Include the JS file where BlogFooter is defined -->
        <script defer src="/js/blog-footer.js"></script>
        <script defer src="/js/blog-header.js"></script>

    </body>
</html>

